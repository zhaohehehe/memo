# Oracle分区表创建

##### LIST分区：分区索引(local/global) 。没有mysql的LIST和**LIST COLUMNS** 分区的区别，INT和STRING都可以。

```
DROP TABLE TEST_GRAPH;
CREATE TABLE TEST_GRAPH (
	OID VARCHAR2(50) NOT NULL ,
	PATH_GRAPH_VALUE CLOB NOT NULL ,
	TENANT_ID VARCHAR2(100) NOT NULL ,
	DELETE_FLAG NUMBER DEFAULT 0 NOT NULL ,
	CREATE_TIME VARCHAR2(20) NOT NULL ,
	NODE_NUMBER NUMBER DEFAULT 0 NOT NULL ,
	PRIMARY KEY (OID, TENANT_ID) USING INDEX LOCAL
) PARTITION BY LIST(TENANT_ID)(
	PARTITION p_test_tenant VALUES ('test_tenant')
);
DROP TABLE TEST_NODE;
CREATE TABLE TEST_NODE (
	OID VARCHAR2(50) NOT NULL ,
	GRAPH_ID VARCHAR2(50) NOT NULL ,
	NODE_ID VARCHAR2(50) NOT NULL ,
	TENANT_ID VARCHAR2(100) NOT NULL ,
	DELETE_FLAG NUMBER DEFAULT 0 NOT NULL ,
	CREATE_TIME VARCHAR2(20) NOT NULL ,
	PRIMARY KEY (OID, TENANT_ID) USING INDEX LOCAL,
	CONSTRAINT UNIQUE_RELATION UNIQUE (GRAPH_ID, NODE_ID, TENANT_ID) USING INDEX LOCAL
) PARTITION BY LIST(TENANT_ID)(
	PARTITION p_test_tenant VALUES ('test_tenant')
);

```

1. 查看分区索引(local/global)是否成功。local索引添加分区时会自动添加分区索引。
   select SEGMENT_NAME,PARTITION_NAME,SEGMENT_TYPE from DBA_SEGMENTS where SEGMENT_NAME='UNIQUE_RELATION';

   索引类型：分区local索引、分区global索、普通索引。

2. 查询表分区
   SELECT PARTITION_NAME from USER_TAB_PARTITIONS WHERE TABLE_NAME = UPPER('TEST_NODE');
   HIGH_VALUE 分区值，但是查询慢。
   SELECT HIGH_VALUE from USER_TAB_PARTITIONS WHERE TABLE_NAME = UPPER('TEST_NODE');

3. 添加表分区
   ALTER TABLE TEST_NODE ADD PARTITION p_tenant1 VALUES ('tenant1');

4. 删除表分区数据(不破坏分区结构)
   ALTER TABLE TEST_NODE TRUNCATE PARTITION p_test_tenant;